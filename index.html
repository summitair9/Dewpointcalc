<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DewPoint</title>

  <!-- Tailwind & Icons -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
  />

  <!-- React + Babel (JSX without build step) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Fonts & Styles -->
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap");
    body {
      font-family: "Inter", sans-serif;
      background-color: #0f172a;
      color: #f8fafc;
      overflow-x: hidden;
      min-height: 100vh;
    }
    .glass {
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .glow-text {
      text-shadow: 0 0 20px rgba(56, 189, 248, 0.5);
    }
    input[type="range"] {
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.1);
      height: 6px;
      border-radius: 5px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #38bdf8;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.8);
    }
    select {
      background-color: transparent;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- REACT APP -->
  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback } = React;

    // ==== Units ====
    const TemperatureUnit = {
      CELSIUS: "C",
      FAHRENHEIT: "F",
    };

    // ==== Conversions ====
    function celsiusToFahrenheit(c) {
      return Math.round(((c * 9) / 5 + 32) * 10) / 10;
    }
    function fahrenheitToCelsius(f) {
      return Math.round(((f - 32) * 5) / 9 * 10) / 10;
    }

    // ==== Dew Point (Magnus) ====
    function calculateDewPointCelsius(T, RH) {
      const b = 17.67;
      const c = 243.5;
      const gamma = Math.log(RH / 100) + (b * T) / (c + T);
      const dewPoint = (c * gamma) / (b - gamma);
      return Math.round(dewPoint * 10) / 10;
    }

    // ==== Comfort text ====
    function getComfortLevel(dewPointC) {
      if (dewPointC < 10) return { label: "Dry & Crisp", color: "text-sky-400", level: 0 };
      if (dewPointC < 15) return { label: "Pleasant", color: "text-emerald-400", level: 1 };
      if (dewPointC < 18) return { label: "Comfortable", color: "text-teal-400", level: 2 };
      if (dewPointC < 21) return { label: "Humid", color: "text-yellow-400", level: 3 };
      if (dewPointC < 24) return { label: "Uncomfortable", color: "text-orange-500", level: 4 };
      return { label: "Oppressive", color: "text-red-500", level: 5 };
    }

    // ==== Atmosphere description (local rules, no API) ====
    function generateAtmosphereDescription(temp, humidity, dewPoint, unit) {
      const unitSymbol = "°" + unit;
      if (humidity < 30 && dewPoint < (unit === "C" ? 5 : 41)) {
        return `Cool, dry air that feels crisp and light at ${temp}${unitSymbol}.`;
      }
      if (humidity < 45) {
        return `Balanced air that feels clean and easy to breathe at ${temp}${unitSymbol}.`;
      }
      if (humidity < 60) {
        return `Soft, mild humidity that wraps gently around your skin at ${temp}${unitSymbol}.`;
      }
      if (humidity < 75) {
        return `Thick, warm air that clings lightly to your skin at ${temp}${unitSymbol}.`;
      }
      return `Heavy, saturated air that presses close against your skin at ${temp}${unitSymbol}.`;
    }

    // ==== DB/WB helper ====
    function calcDbWbHelper(dbF, wbF) {
      const db = parseFloat(dbF);
      const wb = parseFloat(wbF);
      if (isNaN(db) || isNaN(wb)) return null;
      if (wb > db) return null;

      const T = (db - 32) * (5 / 9);
      const Tw = (wb - 32) * (5 / 9);

      const A = 0.00066 * 101.3;
      const esTw = 6.112 * Math.exp((17.67 * Tw) / (Tw + 243.5));
      const e = esTw - A * (T - Tw);
      const esT = 6.112 * Math.exp((17.67 * T) / (T + 243.5));
      let RH = 100 * (e / esT);
      RH = Math.max(0, Math.min(100, RH));

      const dewC = calculateDewPointCelsius(T, RH);
      const dewF = celsiusToFahrenheit(dewC);

      let coilSatF = dewF - 15;
      coilSatF = Math.max(32, Math.min(55, coilSatF));

      return {
        rh: RH,
        dewC,
        dewF,
        coilSatF,
      };
    }

    // ==== PT data (approx, 30–120°F) ====
    const PT_DATA = {
      "R-22": [
        { t: 30, p: 57.5 },
        { t: 40, p: 68.6 },
        { t: 50, p: 84.1 },
        { t: 60, p: 101.6 },
        { t: 70, p: 121.5 },
        { t: 80, p: 143.7 },
        { t: 90, p: 168.4 },
        { t: 100, p: 196.0 },
        { t: 110, p: 226.4 },
        { t: 120, p: 260.0 },
      ],
      "R-410A": [
        { t: 30, p: 101.6 },
        { t: 40, p: 118.9 },
        { t: 50, p: 143.3 },
        { t: 60, p: 170.7 },
        { t: 70, p: 201.5 },
        { t: 80, p: 235.9 },
        { t: 90, p: 274.3 },
        { t: 100, p: 316.9 },
        { t: 110, p: 364.1 },
        { t: 120, p: 416.4 },
      ],
      "R-407C": [
        { t: 30, p: 50.9 },
        { t: 40, p: 61.7 },
        { t: 50, p: 77.1 },
        { t: 60, p: 94.3 },
        { t: 70, p: 138.5 },
        { t: 80, p: 163.5 },
        { t: 90, p: 191.3 },
        { t: 100, p: 222.3 },
        { t: 110, p: 256.5 },
        { t: 120, p: 294.2 },
      ],
      "R-134a": [
        { t: 30, p: 27.8 },
        { t: 40, p: 35.0 },
        { t: 50, p: 45.4 },
        { t: 60, p: 57.4 },
        { t: 70, p: 71.1 },
        { t: 80, p: 86.7 },
        { t: 90, p: 104.3 },
        { t: 100, p: 124.1 },
        { t: 110, p: 146.3 },
        { t: 120, p: 171.1 },
      ],
      "R-404A": [
        { t: 30, p: 73.8 },
        { t: 40, p: 86.9 },
        { t: 50, p: 105.3 },
        { t: 60, p: 126.0 },
        { t: 70, p: 149.3 },
        { t: 80, p: 175.4 },
        { t: 90, p: 204.5 },
        { t: 100, p: 236.8 },
        { t: 110, p: 272.5 },
        { t: 120, p: 312.1 },
      ],
    };

    function ptGetCurve(name) {
      return PT_DATA[name] || null;
    }

    function ptPressureFromTemp(name, tempF) {
      const curve = ptGetCurve(name);
      if (!curve || typeof tempF !== "number" || isNaN(tempF)) return null;
      const pts = curve;
      if (tempF <= pts[0].t) return pts[0].p;
      if (tempF >= pts[pts.length - 1].t) return pts[pts.length - 1].p;
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i];
        const b = pts[i + 1];
        if (tempF >= a.t && tempF <= b.t) {
          const ratio = (tempF - a.t) / (b.t - a.t);
          return a.p + ratio * (b.p - a.p);
        }
      }
      return null;
    }

    function ptTempFromPressure(name, pressure) {
      const curve = ptGetCurve(name);
      if (!curve || typeof pressure !== "number" || isNaN(pressure)) return null;
      const pts = curve.slice().sort((a, b) => a.p - b.p);
      if (pressure <= pts[0].p) return pts[0].t;
      if (pressure >= pts[pts.length - 1].p) return pts[pts.length - 1].t;
      for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i];
        const b = pts[i + 1];
        if (pressure >= a.p && pressure <= b.p) {
          const ratio = (pressure - a.p) / (b.p - a.p);
          return a.t + ratio * (b.t - a.t);
        }
      }
      return null;
    }

    // Large list of refrigerants
    const PT_OPTIONS = [
      "R-410A",
      "R-22",
      "R-407C",
      "R-134a",
      "R-404A",
      "R-407A",
      "R-407F",
      "R-32",
      "R-454B",
      "R-452B",
      "R-448A",
      "R-449A",
      "R-438A (MO99)",
      "R-422D",
      "R-421A",
      "R-427A",
      "R-513A",
      "R-1234yf",
      "R-1234ze",
      "R-290 (Propane)",
      "R-744 (CO2)",
      "R-717 (Ammonia)",
      "R-12",
      "R-502",
      "R-500",
    ];

    function App() {
      // MAIN ATMOSPHERE (DEFAULT °F)
      const [state, setState] = useState({
        temperature: 72,
        humidity: 50,
        unit: TemperatureUnit.FAHRENHEIT,
      });

      const [aiText, setAiText] = useState(
        "Adjust the sliders to feel the atmosphere..."
      );
      const [loadingAi, setLoadingAi] = useState(false);
      const [outdoorTemp, setOutdoorTemp] = useState(null); // °C from API
      const [outdoorLoading, setOutdoorLoading] = useState(false);

      // Location selector
      const [locationMode, setLocationMode] = useState("local");
      const [locationName, setLocationName] = useState("Local");
      const [showLocationMenu, setShowLocationMenu] = useState(false);

      // DB/WB helper state (°F)
      const [dbwb, setDbwb] = useState({
        db: 75,
        wb: 63,
      });

      // ΔT helper state (°F)
      const [dt, setDt] = useState({
        returnDb: 75,
        supplyDb: 55,
      });

      // Airflow / static state
      const [airflow, setAirflow] = useState({
        designCfm: 400,
        designStatic: 0.5,
        returnStatic: 0.08,
        supplyStatic: 0.22,
      });

      // Refrigerant circuit state
      const [refrig, setRefrig] = useState({
        evapSat: 40,
        suctionLine: 55,
        condSat: 110,
        liquidLine: 95,
      });

      // Checklist
      const [checks, setChecks] = useState({
        filter: false,
        coil: false,
        blower: false,
        charge: false,
        ducts: false,
      });

      // Multi-ref PT state
      const [ptState, setPtState] = useState(() => {
        const defRef = "R-410A";
        const defTemp = 40;
        const p = ptPressureFromTemp(defRef, defTemp);
        return {
          refrigerant: defRef,
          tempF: defTemp,
          pressure: p !== null ? p.toFixed(1) : "",
        };
      });

      const sectionOptions = [
        { id: "section-evap-db-wb", label: "Evap Coil Target (DB/WB)" },
        { id: "section-dt-airflow", label: "ΔT Across Coil & Triage" },
        { id: "section-airflow-static", label: "Airflow & Static" },
        { id: "section-refrigerant", label: "Superheat / Subcool" },
        { id: "section-pt-chart", label: "Multi-Refrigerant PT Chart" },
      ];

      const allLocations = [
        { key: "local", name: "Local", type: "local" },
        { key: "nyc", name: "New York, NY", type: "city", lat: 40.7128, lon: -74.006 },
        { key: "mia", name: "Miami, FL", type: "city", lat: 25.7617, lon: -80.1918 },
        { key: "la", name: "Los Angeles, CA", type: "city", lat: 34.0522, lon: -118.2437 },
        { key: "chi", name: "Chicago, IL", type: "city", lat: 41.8781, lon: -87.6298 },
        { key: "dal", name: "Dallas, TX", type: "city", lat: 32.7767, lon: -96.797 },
      ];

      async function fetchWeatherForCoords(latitude, longitude) {
        try {
          setOutdoorLoading(true);
          const res = await fetch(
            `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true`
          );
          const data = await res.json();
          if (data.current_weather) {
            setOutdoorTemp(data.current_weather.temperature); // °C
          }
        } catch (err) {
          console.error("Failed to fetch outdoor weather", err);
        } finally {
          setOutdoorLoading(false);
        }
      }

      const scrollToSection = (id) => {
        if (!id) return;
        const el = document.getElementById(id);
        if (el) {
          el.scrollIntoView({ behavior: "smooth", block: "start" });
        }
      };

      // Derived main atmosphere
      const currentTempC = useMemo(
        () =>
          state.unit === TemperatureUnit.CELSIUS
            ? state.temperature
            : fahrenheitToCelsius(state.temperature),
        [state.temperature, state.unit]
      );

      const dewPointC = useMemo(
        () => calculateDewPointCelsius(currentTempC, state.humidity),
        [currentTempC, state.humidity]
      );

      const dewPointDisplay = useMemo(
        () =>
          state.unit === TemperatureUnit.CELSIUS
            ? dewPointC
            : celsiusToFahrenheit(dewPointC),
        [dewPointC, state.unit]
      );

      const comfort = useMemo(() => getComfortLevel(dewPointC), [dewPointC]);

      // DB/WB
      const dbwbResults = useMemo(
        () => calcDbWbHelper(dbwb.db, dbwb.wb),
        [dbwb.db, dbwb.wb]
      );

      // ΔT across coil
      const deltaTData = useMemo(() => {
        const r = parseFloat(dt.returnDb);
        const s = parseFloat(dt.supplyDb);
        if (isNaN(r) || isNaN(s)) {
          return {
            delta: null,
            label: "--",
            note: "Enter return & supply temps.",
            color: "text-slate-300",
          };
        }

        const d = r - s;
        let label = "";
        let note = "";
        let color = "";

        if (d < 8) {
          label = "Very Low";
          note = "ΔT far below typical. Check airflow first, then charge and load.";
          color = "text-red-400";
        } else if (d < 14) {
          label = "Low";
          note = "Below typical range – verify airflow and refrigerant charge.";
          color = "text-amber-400";
        } else if (d <= 22) {
          label = "In Range";
          note = "Within common comfort-cooling ΔT window.";
          color = "text-emerald-400";
        } else {
          label = "High";
          note = "High ΔT – often points to low airflow or very low load.";
          color = "text-orange-400";
        }

        return { delta: d, label, note, color };
      }, [dt.returnDb, dt.supplyDb]);

      // Airflow / static
      const airflowData = useMemo(() => {
        const designCfm = parseFloat(airflow.designCfm);
        const designStatic = parseFloat(airflow.designStatic);
        const rs = parseFloat(airflow.returnStatic);
        const ss = parseFloat(airflow.supplyStatic);

        if (
          isNaN(designCfm) ||
          designCfm <= 0 ||
          isNaN(designStatic) ||
          designStatic <= 0 ||
          isNaN(rs) ||
          isNaN(ss)
        ) {
          return {
            tesp: null,
            estCfm: null,
            statusLabel: "--",
            statusNote:
              "Enter design airflow and static with measured return/supply.",
            statusColor: "text-slate-300",
          };
        }

        const tesp = Math.abs(rs) + Math.abs(ss);

        let estCfm = null;
        if (tesp > 0.05) {
          const ratio = Math.sqrt(designStatic / tesp);
          estCfm = designCfm * ratio;
          const minCfm = designCfm * 0.5;
          const maxCfm = designCfm * 1.5;
          estCfm = Math.max(minCfm, Math.min(maxCfm, estCfm));
        }

        let statusLabel = "";
        let statusNote = "";
        let statusColor = "";

        if (tesp < designStatic * 0.7) {
          statusLabel = "Static Low";
          statusNote =
            "Total external static is below expected – could be low resistance duct system or low airflow setting.";
          statusColor = "text-sky-300";
        } else if (tesp <= designStatic * 1.2) {
          statusLabel = "Static Normal";
          statusNote =
            "Static near design – airflow likely close to expected if blower setup is correct.";
          statusColor = "text-emerald-400";
        } else {
          statusLabel = "Static High";
          statusNote =
            "Static above design – restrictions, undersized duct, closed registers, dirty filter/coil.";
          statusColor = "text-red-400";
        }

        return {
          tesp,
          estCfm,
          statusLabel,
          statusNote,
          statusColor,
        };
      }, [
        airflow.designCfm,
        airflow.designStatic,
        airflow.returnStatic,
        airflow.supplyStatic,
      ]);

      // Refrigerant (SH/SC)
      const refrigData = useMemo(() => {
        const evapSat = parseFloat(refrig.evapSat);
        const suction = parseFloat(refrig.suctionLine);
        const condSat = parseFloat(refrig.condSat);
        const liquid = parseFloat(refrig.liquidLine);

        if (
          isNaN(evapSat) ||
          isNaN(suction) ||
          isNaN(condSat) ||
          isNaN(liquid)
        ) {
          return {
            superheat: null,
            subcool: null,
            shLabel: "--",
            shNote: "Enter evap saturation and suction line temps.",
            shColor: "text-slate-300",
            scLabel: "--",
            scNote: "Enter condensing saturation and liquid line temps.",
            scColor: "text-slate-300",
          };
        }

        const superheat = suction - evapSat;
        const subcool = condSat - liquid;

        let shLabel = "";
        let shNote = "";
        let shColor = "";
        if (superheat < 5) {
          shLabel = "Very Low";
          shNote =
            "Superheat very low – risk of flooding compressor. Suspect overfeeding or overcharge.";
          shColor = "text-red-400";
        } else if (superheat < 8) {
          shLabel = "Low";
          shNote =
            "Superheat slightly low – watch for overfeeding, TXV issues, or overcharge.";
          shColor = "text-amber-400";
        } else if (superheat <= 20) {
          shLabel = "In Range";
          shNote =
            "Superheat in a common comfort-cooling window. Verify against manufacturer chart.";
          shColor = "text-emerald-400";
        } else {
          shLabel = "High";
          shNote =
            "Superheat high – could be undercharge, restricted feed, or low load/airflow.";
          shColor = "text-orange-400";
        }

        let scLabel = "";
        let scNote = "";
        let scColor = "";
        if (subcool < 5) {
          scLabel = "Low";
          scNote =
            "Subcooling low – suspect undercharge, flash gas, or liquid line issues.";
          scColor = "text-red-400";
        } else if (subcool <= 15) {
          scLabel = "In Range";
          scNote =
            "Subcooling in a typical comfort-cooling band. Confirm with nameplate/charging chart.";
          scColor = "text-emerald-400";
        } else {
          scLabel = "High";
          scNote =
            "Subcooling high – may indicate overcharge or condenser overperforming at current load.";
          scColor = "text-orange-400";
        }

        return {
          superheat,
          subcool,
          shLabel,
          shNote,
          shColor,
          scLabel,
          scNote,
          scColor,
        };
      }, [refrig.evapSat, refrig.suctionLine, refrig.condSat, refrig.liquidLine]);

      // Primary diagnostic focus
      const primaryFocus = useMemo(() => {
        if (deltaTData.delta === null || airflowData.tesp === null) {
          return "Enter ΔT and static values to get a suggested focus.";
        }

        const dtLabel = deltaTData.label;
        const staticLabel = airflowData.statusLabel;

        if (
          (dtLabel === "Very Low" || dtLabel === "Low") &&
          staticLabel === "Static High"
        ) {
          return "Focus on airflow restrictions first: filter, coil, duct size, closed registers, and blower tap or ECM setup.";
        }
        if (
          (dtLabel === "Very Low" || dtLabel === "Low") &&
          staticLabel === "Static Normal"
        ) {
          return "Focus on refrigerant charge and load after basic airflow checks.";
        }
        if (dtLabel === "High" && staticLabel === "Static High") {
          return "Likely low airflow through the coil – expect high superheat, potential freeze risk.";
        }
        if (dtLabel === "High" && staticLabel !== "Static Hi
